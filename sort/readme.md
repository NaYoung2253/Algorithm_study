## 정렬 문제 풀이

### 2751번 문제
> 배운 이론 중 퀵 정렬에 대해 알아보고자 2751번 문제를 풀고자 했다.
> 퀵정렬은 평균적으론 O(Nlogn)이지만, 데이터의 입력이 무작위가 아니라, 이미 데이터가 정렬되어 있는 경우, 매우 느리게 동작한다.
> 따라서, 최악의 경우의 시간 복잡도가 나와 시간 초과가 되었다.
> O(Nlogn)을 보장해주는 파이썬 기본 라이브러리를 이용해 풀 수 있었다.

### 2750번 문제
> 배운 이론 중 병합 정렬에 대해 알아보고자 2750번 문제를 풀고자 했다.
> 병합 정렬은 앞서 2751번 문제에서 사용한 파이썬 기본 라이브러리 sorted()가 기반으로 하는 정렬 알고리즘이다.
> 직접 병합 정렬을 구현해봄으로써, 병합 정렬을 학습하고자 했고, 시간 복잡도는 O(Nlogn)이다.
> 2750번과 2751번 문제가 입력이 순서대로 되는 것처럼 보여, 배운 이론 중, 삽입 정렬을 사용해보는 것도 좋을 것 같다.
> 삽입 정렬은 최선의 경우, O(N) 시간 복잡도를 가지기 때문이다.

### 10989번 문제
> 배운 이론 중 계수 정렬에 대해 알아보고자 10989번 문제를 풀고자 했다.
> 데이터의 개수가 10,000,000개까지 나오기 때문에, 기존에 배운 병합 정렬 혹은 퀵 정렬을 하면 메모리 초과가 된다.
> 삽입 정렬이나 선택 정렬 또한 마찬가지이다.
> 이때 주어지는 데이터가 자연수이고, 데이터의 값의 범위가 10,000을 넘지 않기 때문에 계수 정렬이 가장 적합한 알고리즘이었다.
> 대신, input을 배열에 저장하면 메모리 초과가 되기 때문에, 10,001개의 배열을 만들어 입력받은 수를 바로 count 해주어야 한다.

### 10814번 문제
> 앞서 풀었던 10989번 문제에서 사용한 계수 정렬을 응용하여 문제를 폴고자, 10814번 문제를 풀었다.
> 물론, 병렬 정렬 알고리즘이나, 파이썬 기본 라이브러리를 사용하여 문제를 풀 수도 있었다.
> 하지만, 계수 정렬을 사용해서 문제를 풀 수 있을 때는 시간 단축을 위해서, 사용하는 것이 적합하다고 생각했고,
> 예상대로 시간 복잡도가 괜찮았었다.


### 1377번 문제
> 왠지 모르게 쉬울 것 같아서 도전했던, 버블 소트의 swap 횟수를 구하는 문제를 풀어보았다.
> 버블 소트를 그대로 사용하면, 버블 소트는 시간이 오래 걸려 시간 초과가 나올 것이 분명했다.
> 퀵정렬을 사용해서 풀어보고자 했지만, 퀵정렬은 tail 리스트를 계속 생성해서 정렬하기 때문에, 메모리 초과가 뜨는 것으로 보였다.
> 또 자연수이면서, 작은 수와 큰 수의 차이가 1,000,000인 것을 보고 계수 정렬을 써서 풀어볼까 했지만, 계수정렬은 swap의 횟수를 구하는 데에는 어려웠다.
> 그래서 선택한 알고리즘이 병렬 정렬이었고, 파이썬 기본 라이브러리를 사용해도 괜찮았다.
> 번거로웠던 점은 .index()함수를 쓰면 시간이 오려 걸려서 시간 초과가 떴었고, index를 따로 저장하는 리스트를 만들면 메모리 초과가 떴다.

### 11650번 문제
> 이 문제는 문제 자체는 어렵지 않았지만, 제한 시간이 1초이다.
> 그래서 선택 정렬과 삽입 정렬, 그리고 버블 정렬은 사용할 수 없었다.
> 계수 정렬을 사용하기엔, 좌표이기 때문에 어렵기도 했지만, 퀵 정렬과 병렬 정렬이 있기 때문에, 사용하지 않았다.
> 수가 무작위로 주어졌기 때문에 병렬 정렬보다, 퀵정렬이 시간이 더 빨랐다.
